<!DOCTYPE html>
<html lang="{% if page.language == "cz" %}cs{% else %}en{% endif%}">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		{% if page.redirect.to %}
		<link rel="canonical" href="{{ page.redirect.to }}">
		<meta http-equiv="refresh" content="0; url={{ page.redirect.to }}">
		{% endif %}
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<!-- ICON -->
		<link rel="icon" type="image/svg+xml" href="{{ '/assets/favicon.svg' | absolute_url}}" />
		<link rel="icon" type="image/png" href="{{ '/assets/favicon.png' | absolute_url}}" />

		<!-- PAGE TITLE AND DESCRIPTION -->
		{% if page.order == 0 %}
			<title>{{ site.title }}</title>
		{% elsif page.html_title %}
			<title>{{ page.html_title }} – {{ site.title }}</title>
		{% else %}
			<title>{{ page.title }} – {{ site.title }}</title>
		{% endif %}
		<meta name="description" content="{{site.description}}">

		<!-- CSS STYLESHEETS -->
		<link rel="stylesheet" href="{{ '/assets/css/main.css' | absolute_url}}">
		{% if page.css %}
		{% assign css_names = page.css | split: " " %}
		{% for name in css_names %}
		{% capture url %}/assets/css/{{ name }}.css{% endcapture %}
		<link rel="stylesheet" href="{{ url | absolute_url}}">
		{% endfor %}
		{% endif %}

		<!-- FA -->
		<link rel="stylesheet" href="{{ '/assets/css/fa.min.css' | absolute_url}}">

		<!-- KATEX -->
		<link rel="stylesheet" href="{{ '/assets/css/katex.min.css' | absolute_url}}">

		<!-- CANONICAL -->
		<link rel="canonical" href="{{ page.url | replace:'index.html','' | absolute_url }}">

		<!-- Hide Halloween toggle when JavaScript is disabled -->
		<noscript><style>.halloween-toggle { display: none; }</style></noscript>

		<!-- yoinked from Advent of Code: triple clicking a code snippet selects it in its entirety -->
		<script>window.addEventListener('click', function(e,s,r){if((e.target.nodeName==='PRE'||e.target.nodeName==='CODE')&&e.detail===3){s=window.getSelection();s.removeAllRanges();r=document.createRange();r.selectNodeContents(e.target);s.addRange(r);}});</script>

		<!-- Halloween theme toggle -->
		<script>
			function getCookie(name) {
				const nameEQ = name + "=";
				const cookies = document.cookie.split(';');
				for (let i = 0; i < cookies.length; i++) {
					let cookie = cookies[i].trim();
					if (cookie.indexOf(nameEQ) === 0) {
						return cookie.substring(nameEQ.length);
					}
				}
				return null;
			}

			function setCookie(name, value, days = 365) {
				const date = new Date();
				date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
				const expires = "expires=" + date.toUTCString();
				document.cookie = name + "=" + value + ";" + expires + ";path=/";
			}

			// Ghost movement configuration
			const ghostConfig = {
				// Animation timing
				updateInterval: 10, // milliseconds

				// Velocity-based movement
				maxVelocity: 150, // pixels per second
				accelerationRate: 0.3, // how quickly velocity changes direction
				waypointChangeInterval: 3000, // milliseconds between picking new waypoints

				// Boundary constraints
				boundaryOffset: 25,

				// Opacity based on distance from cursor
				maxOpacity: 0.5,
				maxDistanceForOpacity: 800,

				// Ghost caught behavior
				bobFrequency: 3,
				bobAmplitude: 10,
				caughtDuration: 5, // seconds
			};

			// Mapping of navbar names and icons for halloween mode
			const halloweenNameMapping = {
     			"Home": "Castle",
				"Reading": "Tomes",
				"CV": "Scripture",
				"Climbing": "Adventure",
				"Photos": "Negatives",
				"Videos": "Horror",
				"Stickers": "Stamps",
			};

			const halloweenIconMapping = {
				// Maps original icon class to halloween icon class
				"fa-house": "fa-chess-rook",
				"fa-book": "fa-book-skull",
				"fa-id-card": "fa-scroll",
				"fa-bolt": "fa-person-hiking",
				"fa-camera": "fa-camera-retro",
				"fa-youtube": "fa-video",
				"fa-note-sticky": "fa-stamp",
			};

			// Icon family mappings (for converting between fa-brands, fa-solid, etc.)
			const halloweenIconFamilyMapping = {
				"fa-youtube": { toFamily: "fa-solid", fromFamily: "fa-brands" }
			};

			// Author name mapping for footer
			const halloweenAuthorMapping = {
				"Tomáš Sláma": "<em>the ArchMage <i class=\"fa-solid fa-hat-wizard\"></i></em>"
			};

			function applyNavbarNameMapping() {
				const isHalloween = getCookie('halloween-mode') === 'true';
				const navbarItems = document.querySelectorAll('.navbar-text a');

				navbarItems.forEach(link => {
					// Handle icon mapping
					const iconElement = link.querySelector('i');
					if (iconElement) {
						const classes = Array.from(iconElement.classList);
						classes.forEach(cls => {
							// Check if this is an original icon that needs halloween mapping
							if (halloweenIconMapping[cls]) {
								const mappedIcon = halloweenIconMapping[cls];
								if (isHalloween) {
									iconElement.classList.replace(cls, mappedIcon);
									// Handle family conversion if needed
									if (halloweenIconFamilyMapping[cls]) {
										const familyMap = halloweenIconFamilyMapping[cls];
										iconElement.classList.replace(familyMap.fromFamily, familyMap.toFamily);
									}
								}
							} else {
								// Check if this is a halloween icon that needs to be reversed
								for (let [original, halloween] of Object.entries(halloweenIconMapping)) {
									if (cls === halloween && !isHalloween) {
										iconElement.classList.replace(halloween, original);
										// Handle family conversion back if needed
										if (halloweenIconFamilyMapping[original]) {
											const familyMap = halloweenIconFamilyMapping[original];
											iconElement.classList.replace(familyMap.toFamily, familyMap.fromFamily);
										}
										break;
									}
								}
							}
						});
					}

					// Handle name mapping
					for (let node of link.childNodes) {
						if (node.nodeType === Node.TEXT_NODE) {
							const currentText = node.textContent.trim();
							const mappedName = halloweenNameMapping[currentText];

							// Check if this is an original name that needs halloween mapping
							if (isHalloween && mappedName) {
								node.textContent = ' ' + mappedName;
							} else if (!isHalloween) {
								// Check if this is a halloween name that needs to be reversed
								for (let [original, halloween] of Object.entries(halloweenNameMapping)) {
									if (currentText === halloween) {
										node.textContent = ' ' + original;
										break;
									}
								}
							}
							break; // Only replace the first text node
						}
					}
				});
			}

			function applyAuthorNameMapping() {
				const isHalloween = getCookie('halloween-mode') === 'true';
				const authorElement = document.getElementById('author-name');

				if (authorElement) {
					const currentState = authorElement.getAttribute('data-halloween');

					for (let [original, halloween] of Object.entries(halloweenAuthorMapping)) {
						if (isHalloween && currentState !== 'true') {
							authorElement.innerHTML = halloween;
							authorElement.setAttribute('data-halloween', 'true');
						} else if (!isHalloween && currentState === 'true') {
							authorElement.innerHTML = original;
							authorElement.setAttribute('data-halloween', 'false');
						}
					}
				}
			}

			function applyHalloweenTheme() {
				const isHalloween = getCookie('halloween-mode') === 'true';
				const root = document.documentElement;
				if (isHalloween) {
					root.classList.add('halloween');
				} else {
					root.classList.remove('halloween');
				}
			}

			function toggleHalloween() {
				const root = document.documentElement;
				const isCurrentlyHalloween = root.classList.contains('halloween');

				if (isCurrentlyHalloween) {
					setCookie('halloween-mode', 'false');
					root.classList.remove('halloween');
				} else {
					setCookie('halloween-mode', 'true');
					root.classList.add('halloween');
				}
				applyNavbarNameMapping();
				applyAuthorNameMapping();
				updateGhostCursorVisibility();
			}

			function updateGhostCursorVisibility() {
				const ghostCursor = document.getElementById('ghost-cursor');
				const isHalloween = getCookie('halloween-mode') === 'true';
				ghostCursor.style.display = isHalloween ? 'block' : 'none';
			}

			// Ghost cursor position tracking
			let ghostX = window.innerWidth / 2;
			let ghostY = window.innerHeight / 2;
			let velocityX = 0;
			let velocityY = 0;
			let targetX = window.innerWidth / 2;
			let targetY = window.innerHeight / 2;
			let cursorX = window.innerWidth; // Start cursor position far away
			let cursorY = window.innerHeight;
			let ghostCaught = false;
			let caughtTime = 0;
			let lastWaypointChange = 0;

			// Spawn ghost at random location or load from storage
			function spawnGhostRandomly() {
				const offset = ghostConfig.boundaryOffset;
				const savedState = localStorage.getItem('ghostState');

				if (savedState) {
					const state = JSON.parse(savedState);
					ghostX = state.x;
					ghostY = state.y;
					velocityX = state.vx;
					velocityY = state.vy;
				} else {
					ghostX = Math.random() * (window.innerWidth - 2 * offset) + offset;
					ghostY = Math.random() * (window.innerHeight - 2 * offset) + offset;
					velocityX = 0;
					velocityY = 0;
				}
			}

			// Save ghost state (position and velocity) to localStorage
			function saveGhostState() {
				localStorage.setItem('ghostState', JSON.stringify({
					x: ghostX,
					y: ghostY,
					vx: velocityX,
					vy: velocityY
				}));
			}

			// Create wavy text animation
			function createWavyText(text) {
				const letters = text.split('');
				const time = Date.now() / 200; // Speed of wave animation
				return letters.map((letter, index) => {
					const yOffset = Math.sin(index * 0.4 + time) * 5; // Amplitude of 5px, animated wave
					const charDisplay = letter === ' ' ? '&nbsp;' : letter;
					return `<span style="display: inline-block; transform: translateY(${yOffset}px);">${charDisplay}</span>`;
				}).join('');
			}

			// Generate random waypoint within screen bounds
			function generateRandomWaypoint() {
				const offset = ghostConfig.boundaryOffset;
				targetX = Math.random() * (window.innerWidth - 2 * offset) + offset;
				targetY = Math.random() * (window.innerHeight - 2 * offset) + offset;
				lastWaypointChange = Date.now();
			}

			// Track cursor position
			document.addEventListener('mousemove', function(e) {
				cursorX = e.clientX;
				cursorY = e.clientY;
			});

			// Initialize ghost animation after DOM loads
			function initGhostAnimation() {
				const ghostCursor = document.getElementById('ghost-cursor');
				const ghostText = document.getElementById('ghost-text');

				if (!ghostCursor || !ghostText) return;

				// Spawn ghost at random location
				spawnGhostRandomly();
				// Generate initial waypoint
				generateRandomWaypoint();

				// Animate ghost with velocity-based movement
				setInterval(function() {

					if (ghostCursor && ghostCursor.style.display !== 'none') {
						if (!ghostCaught) {
							// Check if we need a new waypoint
							if (Date.now() - lastWaypointChange >= ghostConfig.waypointChangeInterval) {
								generateRandomWaypoint();
							}

							// Calculate direction to target
							const dx = targetX - ghostX;
							const dy = targetY - ghostY;
							const distance = Math.sqrt(dx * dx + dy * dy);

							// Update velocity towards target
							if (distance > 10) {
								const dirX = dx / distance;
								const dirY = dy / distance;
								velocityX += dirX * ghostConfig.accelerationRate;
								velocityY += dirY * ghostConfig.accelerationRate;

								// Limit velocity to max
								const currentSpeed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
								if (currentSpeed > ghostConfig.maxVelocity) {
									const scale = ghostConfig.maxVelocity / currentSpeed;
									velocityX *= scale;
									velocityY *= scale;
								}
							} else {
								// Reached waypoint, slow down
								velocityX *= 0.9;
								velocityY *= 0.9;
							}

							// Apply repulsive force from borders
							const offset = ghostConfig.boundaryOffset;
							const repulsionRange = 150; // Distance at which repulsion starts
							const repulsionStrength = 0.2;

							// Left/Right borders
							if (ghostX < offset + repulsionRange) {
								const repulsion = (1 - (ghostX - offset) / repulsionRange) * repulsionStrength;
								velocityX += repulsion;
							} else if (ghostX > window.innerWidth - offset - repulsionRange) {
								const repulsion = (1 - (window.innerWidth - offset - ghostX) / repulsionRange) * repulsionStrength;
								velocityX -= repulsion;
							}

							// Top/Bottom borders
							if (ghostY < offset + repulsionRange) {
								const repulsion = (1 - (ghostY - offset) / repulsionRange) * repulsionStrength;
								velocityY += repulsion;
							} else if (ghostY > window.innerHeight - offset - repulsionRange) {
								const repulsion = (1 - (window.innerHeight - offset - ghostY) / repulsionRange) * repulsionStrength;
								velocityY -= repulsion;
							}

							// Update position
							const deltaTime = ghostConfig.updateInterval / 1000;
							ghostX += velocityX * deltaTime;
							ghostY += velocityY * deltaTime;

							// Hard bounds to prevent going off-screen
							ghostX = Math.max(offset, Math.min(window.innerWidth - offset, ghostX));
							ghostY = Math.max(offset, Math.min(window.innerHeight - offset, ghostY));

							ghostCursor.style.left = ghostX + 'px';
							ghostCursor.style.top = ghostY + 'px';

							// Save state periodically (every 500ms to avoid excessive writes)
							if (Math.random() < 0.05) {
								saveGhostState();
							}

							// Calculate distance to cursor and adjust opacity
							const distanceToCursor = Math.sqrt(Math.pow(ghostX - cursorX, 2) + Math.pow(ghostY - cursorY, 2));
							const maxDistance = ghostConfig.maxDistanceForOpacity;
							const opacity = Math.max(0, Math.min(ghostConfig.maxOpacity, ghostConfig.maxOpacity * (1 - (distanceToCursor / maxDistance))));
							ghostCursor.style.opacity = opacity;
						} else {
							// Bob up and down while caught
							const bobOffset = Math.sin((Date.now() / 1000) * ghostConfig.bobFrequency) * ghostConfig.bobAmplitude;
							ghostCursor.style.top = (ghostY + bobOffset) + 'px';
							ghostCursor.style.opacity = 1; // Fully opaque when caught

							// Update countdown
							caughtTime -= (ghostConfig.updateInterval / 1000);
							const secondsLeft = Math.max(0, Math.ceil(caughtTime));
							const displayText = secondsLeft > 0 ? 'Goooot your cursoooor (' + secondsLeft + 's)' : 'Got your cursor lmao';
							ghostText.innerHTML = createWavyText(displayText);

							// Release cursor after configured duration
							if (caughtTime <= 0) {
								ghostCaught = false;
								document.body.style.setProperty('cursor', 'auto', 'important');
								// Reset cursor on all elements
								document.querySelectorAll('*').forEach(el => {
									el.style.removeProperty('cursor');
								});
								ghostText.style.display = 'none';
							}
						}
					}
				}, ghostConfig.updateInterval);  // Update interval from config

				// Detect hover on ghost to steal cursor
				ghostCursor.addEventListener('mouseenter', function() {
					if (!ghostCaught && ghostCursor.style.display !== 'none') {
						ghostCaught = true;
						caughtTime = ghostConfig.caughtDuration;
						document.body.style.setProperty('cursor', 'none', 'important');
						// Also set cursor: none on all elements
						document.querySelectorAll('*').forEach(el => {
							el.style.setProperty('cursor', 'none', 'important');
						});
						ghostText.style.display = 'block';
					}
				});
			}

			// Start animation when DOM is ready
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initGhostAnimation);
			} else {
				initGhostAnimation();
			}

			// Apply theme immediately (synchronous, runs before body renders)
			applyHalloweenTheme();
		</script>
	</head>

	<body>
		<!-- Cursor following ghost -->
		<div id="ghost-cursor" style="display: none; position: fixed; font-size: 60px; z-index: 9999; opacity: 0; transition: opacity 0.1s;">
			<i class="fa-solid fa-ghost"></i>
			<div id="ghost-text" style="display: none; position: absolute; top: 85px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 12px; color: #fff; text-shadow: 0 0 3px rgba(0,0,0,0.8); font-family: Arial, sans-serif; pointer-events: none;">Got your cursor lmao</div>
		</div>
		<div class="header">
			<h1><a href="/">{{ site.title }}</a></h1>
		</div>

		<!-- navigation bar -->
		<div class="navigation-background">
			<div class="navigation">
				<ul>
				{% assign sections_sorted = site.documents | concat: site.pages | sort: 'order' %}
				{% for p in sections_sorted %}
					{% if p.title and p.order %}
						<li>
						<span class="navbar-item">
						{% if p.title == page.title %}
							<span class="current-page-item navbar-text"><a href="{{p.url}}">{% if p.icon %}<i class="{% if p.icon contains 'fa-brands' %}{{p.icon}}{% else %}fa-solid {{p.icon}}{% endif %}"></i> {% endif %}{{p.title}}</a></span>
						{% else %}
							<span class="navbar-text"><a href="{{p.url}}">{% if p.icon %}<i class="{% if p.icon contains 'fa-brands' %}{{p.icon}}{% else %}fa-solid {{p.icon}}{% endif %}"></i> {% endif %}{{p.title}}</a></span>
						{% endif %}
						</span>
						</li>
					{% endif %}
				{% endfor %}
				<li>
					<span class="navbar-item">
						<span class="navbar-text"><a class="nohashtag" href="#" onclick="toggleHalloween(); return false;">🎃</a></span>
					</span>
				</li>
				</ul>
			</div>
		</div>

		<div class="content-background">

			<div class="content">
				{% if page.redirect.to %}
				<div class='center'>
					<h2>Getting redirected...</h2>
					<a href="{{ page.redirect.to }}">Click here if you are not redirected.</a>
					<div class="spacer"></div>
				</div>
				{% else %}
				{% unless page.no-heading %}
					{% if page.center-title %}
						<h2 class="center {% if layout.post-title %} post-title{% endif %}">{% if page.category_icon %}<img class='icon' src='{{ page.category_icon }}' alt='{{ page.category | default: page.category_noslug }} Icon'/>{% endif %} {{ page.title }}</h2>
					{% else %}

						<h2 class="{% if layout.post-title %} post-title{% endif %}">{% if page.category_icon %}<img class='icon' src='{{ page.category_icon }}' alt='{{ page.category | default: page.category_noslug }} Icon'/>{% endif %} {{ page.title }}</h2>
					{% endif %}
				{% else %}
					<h2 class='no-display'>{{ page.title }}</h2>
				{% endunless %}
				{% endif %}

				{{ content }}
			</div>
		</div>

		<footer>
			<p>Maintained by <span id="author-name">Tomáš Sláma</span>.</p>
			<p class="large no-link-color">
				<a href="https://www.youtube.com/channel/UC_IaBSHmisYbiYlv32EeNkQ"><i class="fa-brands fa-youtube"></i></a>
				<span class="tiny-vspace"></span>
				<a href="https://bsky.app/profile/tomas.slama.dev"><i class="fa-brands fa-bluesky"></i></a>
				<span class="tiny-vspace"></span>
				<a href="https://github.com/xiaoxiae"><i class="fa-brands fa-github"></i></a>
				<span class="tiny-vspace"></span>
				<a href="https://open.spotify.com/playlist/6tzOl4stxMsAClqNaUalBg?si=466aa28329d143fd"><i class="fa-brands fa-spotify"></i></a>
				<span class="vspace"></span>
				<a href="mailto: tomas@slama.dev"><i class="fa-solid fa-at"></i></a>
				<span class="tiny-vspace"></span>
				<a href="/feed.xml"><i class="fa-solid fa-rss"></i></a>
			</p>
			<p class="small">
				<a href="https://github.com/xiaoxiae/slama.dev">source code</a>
				<span class="half-visible vspace">·</span>
				<a href="/privacy-policy/">privacy policy</a>
				<span class="half-visible vspace">·</span>
    			<span>🇨🇿 🇵🇸 🇺🇦</span>
			</p>
		</footer>

		<!-- Apply navbar name mapping after DOM is loaded -->
		<script>
			applyNavbarNameMapping();
			applyAuthorNameMapping();
			updateGhostCursorVisibility();
			document.addEventListener('DOMContentLoaded', function() {
				applyNavbarNameMapping();
				applyAuthorNameMapping();
				updateGhostCursorVisibility();
			});
		</script>
	</body>
</html>
